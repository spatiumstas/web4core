<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <link rel="stylesheet" href="style.css">
    <link rel="icon" type="image/png" href="https://img.icons8.com/fluency/240/security-configuration.png">
    <link rel="shortcut icon" href="https://img.icons8.com/fluency/240/security-configuration.png">
    <link rel="apple-touch-icon" href="https://img.icons8.com/fluency/240/security-configuration.png">
    <title>web4core</title>
</head>
<body>
<header id="asciiHeader">
    <pre>
                __    __ __                     
 _      _____  / /_  / // / _________  ________ 
| | /| / / _ \/ __ \/ // /_/ ___/ __ \/ ___/ _ \
| |/ |/ /  __/ /_/ /__  __/ /__/ /_/ / /  /  __/
|__/|__/\___/_.___/  /_/  \___/\____/_/   \___/ 
    </pre>
</header>
<svg xmlns="http://www.w3.org/2000/svg" style="display:none">
    <symbol id="copy" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
            stroke-linejoin="round">
        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
    </symbol>
    <symbol id="download-file" viewBox="0 0 16 16" fill="none">
        <path d="M11.727 9.2a.8.8 0 0 0-1.054-1.204L8.8 9.635V1.798a.8.8 0 0 0-1.6 0v7.837l-1.873-1.64A.8.8 0 0 0 4.273 9.2l3.2 2.8a.8.8 0 0 0 1.054 0l3.2-2.8ZM1.6 11.398a.8.8 0 0 0-1.6 0v2.4a1.6 1.6 0 0 0 1.6 1.6h12.8a1.6 1.6 0 0 0 1.6-1.6v-2.4a.8.8 0 0 0-1.6 0v2.4H1.6v-2.4Z"
              fill="currentColor"/>
    </symbol>
    <symbol id="check-mark-small" viewBox="0 0 16 16" fill="currentColor">
        <path d="M6.173 12.414l-3.89-3.89 1.414-1.414 2.476 2.475 6.364-6.364 1.414 1.414-7.778 7.778z"/>
    </symbol>
</svg>
<main class="container container--stretch">
    <div class="row row--left gap-12">
        <div id="coreToggle" class="core-toggle" data-core="singbox" aria-label="Core selector" role="switch"
             aria-checked="true" tabindex="0">
            <div class="knob"></div>
            <div class="labels">
                <span id="lblSing">sing-box</span>
                <span id="lblXray">Xray</span>
                <span id="lblMihomo">Mihomo</span>
            </div>
        </div>
        <label class="custom-checkbox">
            <input type="checkbox" id="cbTun" checked/>
            <div class="checkmark"></div>
            <span>TUN</span>
        </label>
        <label class="custom-checkbox">
            <input type="checkbox" id="cbSocks" checked/>
            <div class="checkmark"></div>
            <span>SOCKS5</span>
        </label>
        <label class="custom-checkbox">
            <input type="checkbox" id="cbClashSecret"/>
            <div class="checkmark"></div>
            <span title="Clash API Secret">Clash Secret</span>
        </label>
        <label class="custom-checkbox">
            <input type="checkbox" id="cbExtended"/>
            <div class="checkmark"></div>
            <span title="Extended features (XHTTP, XUDP, SDNS, Unified delay)">Extended</span>
        </label>
        <input class="input" type="text" id="tunName" placeholder="Interface(s): (tun0,tun1 or tun0:select,tun1:auto)"/>
    </div>

    <div class="full">
        <textarea id="links" class="input full"
                  placeholder="subscription link&#10;vless://...&#10;vmess://...&#10;trojan://...&#10;ss://...&#10;socks://...&#10;http://user:pass@host:port&#10;hy2://...&#10;tuic://...&#10;mieru://... (or json)&#10;sdns://...&#10"></textarea>
    </div>

    <div id="errorBlock" class="row row--left" role="status" aria-live="polite">
        <div id="errorText"></div>
    </div>

    <div class="button-row">
        <input type="submit" id="gen" value="Generate"/>
        <button id="btnReverse" class="btn-primary is-hidden" aria-label="Reverse">Reverse</button>
    </div>

    <div id="outBlock" class="hidden full">
        <textarea id="out" class="input full" readonly></textarea>
        <div class="button-row mt-8 full">
            <button id="btnCopy" class="circle-btn" title="Copy" aria-label="Copy">
                <svg width="22" height="22" aria-hidden="true">
                    <use href="#copy"></use>
                </svg>
            </button>
            <button id="btnDownload" class="circle-btn" title="Download" aria-label="Download">
                <svg width="22" height="22" aria-hidden="true">
                    <use href="#download-file"></use>
                </svg>
            </button>
        </div>
    </div>
</main>
<script src="main.js"></script>
<script>
    let currentCore = 'singbox';
    const coreToggle = document.getElementById('coreToggle');
    const lblSing = document.getElementById('lblSing');
    const lblXray = document.getElementById('lblXray');
    const lblMihomo = document.getElementById('lblMihomo');
    const outBlock = document.getElementById('outBlock');
    const errorBlock = document.getElementById('errorBlock');
    const errorText = document.getElementById('errorText');
    const toggleHidden = (el, hidden) => {
        if (el) {
            el.classList.toggle('is-hidden', hidden);
        }
    };

    function setCore(core) {
        currentCore = core;
        coreToggle.setAttribute('data-core', core);
        coreToggle.setAttribute('aria-checked', core === 'singbox');
        const cbTun = document.getElementById('cbTun');
        const cbTunLabel = cbTun?.parentElement;
        const cbSocksLabel = document.getElementById('cbSocks')?.parentElement;
        const cbClashSecretLabel = document.getElementById('cbClashSecret')?.parentElement;
        const cbExtendedLabel = document.getElementById('cbExtended')?.parentElement;
        const tunNameInput = document.getElementById('tunName');
        const hide = core !== 'singbox';
        toggleHidden(cbTunLabel, hide);
        toggleHidden(cbSocksLabel, hide);
        toggleHidden(cbClashSecretLabel, hide);
        toggleHidden(cbExtendedLabel, hide);
        toggleHidden(tunNameInput, hide);

    }

    lblSing.addEventListener('click', (e) => {
        e.stopPropagation();
        setCore('singbox');
        validateField(false);
    });
    lblXray.addEventListener('click', (e) => {
        e.stopPropagation();
        setCore('xray');
        validateField(false);
    });
    lblMihomo.addEventListener('click', (e) => {
        e.stopPropagation();
        setCore('mihomo');
        validateField(false);
    });

    let dragging = false;
    let startX = 0;
    let moved = false;
    let suppressClick = false;
    coreToggle.addEventListener('mousedown', (e) => {
        dragging = true;
        moved = false;
        startX = e.clientX;
    });
    window.addEventListener('mouseup', () => {
        if (dragging && moved) {
            suppressClick = true;
            setTimeout(() => suppressClick = false, 0);
        }
        dragging = false;
    });
    window.addEventListener('mousemove', (e) => {
        if (!dragging) return;
        const dx = e.clientX - startX;
        if (dx > 10) {
            setCore('xray');
            moved = true;
        }
        if (dx < -10) {
            setCore('singbox');
            moved = true;
        }
    });

    const outEl = document.getElementById('out');

    function setupCheckboxValidation() {
        const cbTun = document.getElementById('cbTun');
        const cbSocks = document.getElementById('cbSocks');
        const cbExtended = document.getElementById('cbExtended');
        if (!cbTun || !cbSocks) return;

        cbTun.addEventListener('change', () => {
            if (!cbTun.checked && !cbSocks.checked) {
                cbSocks.checked = true;
            }
        });

        cbSocks.addEventListener('change', () => {
            if (!cbTun.checked && !cbSocks.checked) {
                cbTun.checked = true;
            }
        });
        if (cbExtended) {
            cbExtended.addEventListener('change', () => {
                validateField(false);
            });
        }
    }

    function validateField(showOutput) {
        const genBtn = document.getElementById('gen');
        const raw = document.getElementById('links').value;
        const tunName = document.getElementById('tunName').value.trim();
        const addTun = !!document.getElementById('cbTun')?.checked;
        const addSocks = !!document.getElementById('cbSocks')?.checked;
        const genClashSecret = !!document.getElementById('cbClashSecret')?.checked;
        const useExtended = !!document.getElementById('cbExtended')?.checked;
        try {
            if (!raw.trim()) {
                if (genBtn) genBtn.disabled = true;
                errorText.textContent = '';
                outBlock.classList.add('hidden');
                document.getElementById('links').classList.remove('input-error');
                return false;
            }
            const beans = buildBeansFromInput(raw);
            if (!beans.length) throw new Error('No valid links or profiles provided');
            beans.forEach(validateBean);
            if (currentCore === 'xray') {
                const unsupported = beans.filter(b => ['hy2', 'tuic', 'mieru', 'sdns'].includes(b.proto));
                if (unsupported.length) {
                    const names = Array.from(new Set(unsupported.map(b => b.proto))).join(', ');
                    throw new Error('Xray does not support: ' + names);
                }
            } else if (currentCore === 'mihomo') {
                const unsupported = beans.filter(b => ['mieru', 'sdns'].includes(b.proto));
                if (unsupported.length) {
                    const names = Array.from(new Set(unsupported.map(b => b.proto))).join(', ');
                    throw new Error('Mihomo does not support: ' + names);
                }
            }
            if (!useExtended && currentCore === 'singbox') {
                const hasExtendedOnly = beans.some(b => b.proto === 'mieru' || b.proto === 'sdns');
                if (hasExtendedOnly) {
                    throw new Error('Enable Extended to generate Mieru/SDNS configurations');
                }
            }
            if (!showOutput) {
                errorText.textContent = '';
                if (genBtn) genBtn.disabled = false;
                document.getElementById('links').classList.remove('input-error');
                return {beans, tunName, addTun, addSocks, genClashSecret, useExtended};
            }
            let finalConfig;
            if (currentCore === 'singbox') {
                const opts = {addTun: addTun, addSocks: addSocks, tunName, genClashSecret, useExtended};
                {
                    const used = new Set();
                    const dnsBeans = useExtended ? beans.filter(b => b.proto === 'sdns') : [];
                    const outboundBeans = beans.filter(b => b.proto !== 'sdns');
                    const outbounds = outboundBeans.map(b => {
                        b._useExtended = !!useExtended;
                        const ob = buildSingBoxOutbound(b);
                        const tag = computeTag(b, used);
                        return Object.assign({tag}, ob);
                    });
                    opts.dnsBeans = dnsBeans;
                    finalConfig = buildSingBoxConfig(outbounds, opts);
                }
            } else if (currentCore === 'xray') {
                if (beans.length === 1) {
                    const ob = buildXrayOutbound(beans[0]);
                    finalConfig = buildXrayConfig(ob);
                } else {
                    const used = new Set();
                    const outbounds = beans.map(b => {
                        const ob = buildXrayOutbound(b);
                        ob.tag = computeTag(b, used);
                        return ob;
                    });
                    finalConfig = buildXrayConfig(outbounds);
                }
            } else if (currentCore === 'mihomo') {
                const unsupported = beans.filter(b => ['mieru', 'sdns'].includes(b.proto));
                if (unsupported.length) {
                    const names = Array.from(new Set(unsupported.map(b => b.proto))).join(', ');
                    throw new Error('Mihomo does not support: ' + names);
                }
                const outBeans = beans.filter(b => !['mieru', 'sdns'].includes(b.proto));
                const yamlObj = buildMihomoConfig(outBeans);
                outEl.value = overlayMihomoYaml(MIHOMO_DEFAULT_TEMPLATE, yamlObj.proxies, yamlObj['proxy-groups']);
                errorText.textContent = '';
                outBlock.classList.remove('hidden');
                if (genBtn) genBtn.disabled = false;
                document.getElementById('links').classList.remove('input-error');
                return true;
            }
            outEl.value = JSON.stringify(finalConfig, null, 2);
            errorText.textContent = '';
            outBlock.classList.remove('hidden');
            if (genBtn) genBtn.disabled = false;
            document.getElementById('links').classList.remove('input-error');
            return true;
        } catch (e) {
            errorText.textContent = (e && e.message ? e.message : String(e));
            if (genBtn) genBtn.disabled = true;
            if (showOutput) {
                outBlock.classList.add('hidden');
            }
            document.getElementById('links').classList.add('input-error');
            return false;
        }
    }

    document.getElementById('gen').addEventListener('click', () => {
        const genBtn = document.getElementById('gen');
        const linksEl = document.getElementById('links');
        const raw = (linksEl?.value || '').trim();
        const maybeUrl = raw.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
        const isSingleHttp = maybeUrl.length === 1 && /^https?:\/\//i.test(maybeUrl[0]) && !/@/.test(maybeUrl[0]);
        const hasPathBeyondRoot = (() => {
            try {
                const u = new URL(maybeUrl[0]);
                return (u.pathname && u.pathname !== '/');
            } catch {
                return false;
            }
        })();
        const shouldTreatAsSub = isSingleHttp && hasPathBeyondRoot;
        if (shouldTreatAsSub && window._fetchSubscription) {
            if (genBtn) genBtn.disabled = true;
            errorText.textContent = '';
            window._fetchSubscription(maybeUrl[0]).then(text => {
                if (!text) {
                    throw new Error('Subscription returned no valid links');
                }
                linksEl.value = text;
                const ok = validateField(true);
                if (!ok) {
                    linksEl.value = raw;
                }
            }).catch((e) => {
                const msg = (e && e.message) ? e.message : 'Network error';
                errorText.textContent = 'Failed to fetch subscription: ' + msg;
                document.getElementById('outBlock').classList.add('hidden');
                linksEl.classList.add('input-error');
            }).finally(() => {
                if (genBtn) genBtn.disabled = false;
            });
            return;
        }
        const ok = validateField(true);
        if (ok) {
            const block = document.getElementById('outBlock');
            if (block && block.scrollIntoView) {
                block.scrollIntoView({behavior: 'smooth', block: 'center', inline: 'nearest'});
            }
            const outEl = document.getElementById('out');
            if (outEl && outEl.focus) {
                try {
                    outEl.focus({preventScroll: true});
                } catch {
                }
            }
        }
    });

    const btnCopy = document.getElementById('btnCopy');
    const btnDownload = document.getElementById('btnDownload');
    btnCopy.addEventListener('click', async () => {
        try {
            await navigator.clipboard.writeText(outEl.value || '');
            const useEl = btnCopy.querySelector('use');
            useEl.setAttribute('href', '#check-mark-small');
            setTimeout(() => {
                useEl.setAttribute('href', '#copy');
            }, 3000);
        } catch {
        }
    });
    btnDownload.addEventListener('click', () => {
        const isYaml = currentCore === 'mihomo';
        const blob = new Blob([outEl.value || ''], {type: isYaml ? 'text/yaml' : 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = (currentCore === 'singbox' ? 'singbox_config.json' : (currentCore === 'xray' ? 'xray_config.json' : 'mihomo_config.yaml'));
        a.click();
        URL.revokeObjectURL(url);
    });

    setupCheckboxValidation();

    const linksInput = document.getElementById('links');
    const genBtn = document.getElementById('gen');
    if (genBtn) genBtn.disabled = true;

    const btnReverse = document.getElementById('btnReverse');

    function looksLikeJsonConfig(text) {
        const t = (text || '').trim();
        if (!t || (t[0] !== '{' && t[0] !== '[')) return false;
        try {
            const obj = JSON.parse(t);
            return obj && typeof obj === 'object' && Array.isArray(obj.outbounds) && obj.outbounds.length > 0;
        } catch {
            return false;
        }
    }

    function isReverseOnlyJson(text) {
        const t = (text || '').trim();
        if (!t || (t[0] !== '{' && t[0] !== '[')) return false;
        try {
            const obj = JSON.parse(t);
            return !!(obj && typeof obj === 'object' && Array.isArray(obj.outbounds) && obj.outbounds.length > 0 && !obj.profiles);
        } catch {
            return false;
        }
    }

    function toggleReverseVisibility() {
        if (!btnReverse) return;
        const raw = (document.getElementById('links')?.value || '').trim();
        const show = looksLikeJsonConfig(raw);
        btnReverse.classList.toggle('is-hidden', !show);
    }

    const triggerLiveValidation = () => {
        if (linksInput && isReverseOnlyJson(linksInput.value)) return;
        validateField(false);
    };
    if (linksInput) {
        const handleJsonMode = () => {
            const raw = (linksInput.value || '').trim();
            const reverseOnly = isReverseOnlyJson(raw);
            const genBtn = document.getElementById('gen');
            if (genBtn) genBtn.disabled = reverseOnly || !raw;
            if (reverseOnly) {
                errorText.textContent = '';
                outBlock.classList.add('hidden');
                linksInput.classList.remove('input-error');
            }
        };
        const updateJsonUiState = () => {
            toggleReverseVisibility();
            handleJsonMode();
        };
        linksInput.addEventListener('input', () => {
            triggerLiveValidation();
            updateJsonUiState();
        });
        linksInput.addEventListener('blur', () => {
            triggerLiveValidation();
            updateJsonUiState();
        });
        updateJsonUiState();
    }
    if (btnReverse) {
        toggleReverseVisibility();
        btnReverse.addEventListener('click', () => {
            const raw = (document.getElementById('links')?.value || '').trim();
            try {
                if (!window._reverseConvert) throw new Error('Reverse converter is not available');
                const text = window._reverseConvert(raw);
                if (!text) throw new Error('No links generated from config');
                outEl.value = text;
                errorText.textContent = '';
                outBlock.classList.remove('hidden');
                document.getElementById('links').classList.remove('input-error');
                const block = document.getElementById('outBlock');
                if (block && block.scrollIntoView) block.scrollIntoView({
                    behavior: 'smooth',
                    block: 'center',
                    inline: 'nearest'
                });
                if (outEl && outEl.focus) {
                    try {
                        outEl.focus({preventScroll: true});
                    } catch {
                    }
                }
            } catch (e) {
                errorText.textContent = (e && e.message) ? e.message : 'Reverse failed';
                outBlock.classList.add('hidden');
                document.getElementById('links').classList.add('input-error');
            }
        });
    }

    const header = document.getElementById('asciiHeader');
    if (header) {
        header.addEventListener('click', function () {
            location.reload();
        });
    }
</script>
</body>
</html>
