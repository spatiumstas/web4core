name: Validate & Deploy

on:
  push:
    branches: [ main ]

permissions:
  contents: read
  pages: write
  id-token: write

jobs:
  validate-singbox:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          cache: false
          go-version: '1.21'

      - name: Download sing-box
        run: |
          # Get latest release info
          LATEST_RELEASE=$(curl -s https://api.github.com/repos/SagerNet/sing-box/releases/latest)
          DOWNLOAD_URL=$(echo $LATEST_RELEASE | jq -r '.assets[] | select(.name | contains("linux-amd64.tar.gz")) | .browser_download_url')
          VERSION=$(echo $LATEST_RELEASE | jq -r '.tag_name')
          
          echo "Downloading sing-box $VERSION from $DOWNLOAD_URL"
          wget -O sing-box.tar.gz "$DOWNLOAD_URL"
          tar -xzf sing-box.tar.gz
          sudo mv sing-box-*/sing-box /usr/local/bin/
          chmod +x /usr/local/bin/sing-box

      - name: Generate and validate sing-box configs
        env:
          CONFIGS: ${{ secrets.CONFIGS }}
        run: |
          # Create test script
          cat > test_singbox.js << 'EOF'
          // Load main.js functions
          const fs = require('fs');
          const vm = require('vm');
          
          // Read main.js content
          const mainJs = fs.readFileSync('src/main.js', 'utf8');
          const singboxJs = fs.readFileSync('src/core/singbox.js', 'utf8');
          
          // Create sandbox with required globals
          const sandbox = {
            console: console,
            require: require,
            module: { exports: {} },
            exports: {},
            global: global,
            process: process,
            Buffer: Buffer,
            setTimeout: setTimeout,
            setInterval: setInterval,
            clearTimeout: clearTimeout,
            clearInterval: clearInterval,
            // Browser APIs for Node.js
            URL: require('url').URL,
            atob: (str) => Buffer.from(str, 'base64').toString('binary'),
            btoa: (str) => Buffer.from(str, 'binary').toString('base64')
          };
          
          // Execute main.js in sandbox
          vm.createContext(sandbox);
          vm.runInContext(mainJs, sandbox);
          vm.runInContext(singboxJs, sandbox);
          
          // Read test configs
          const testLinksContent = process.env.CONFIGS;
          const testLinks = testLinksContent
            .split('\n')
            .map(line => line.trim())
            .filter(line => line && !line.startsWith('//') && !line.startsWith('#'))
            .filter(line => line.includes('://'));
          
          console.log(`Found ${testLinks.length} test links`);
          
          let failedTests = 0;
          let validTests = 0;
          
          for (let i = 0; i < testLinks.length; i++) {
            const link = testLinks[i];
            // Derive a safe display name from hash-part; avoid leaking full link
            const rawHash = link.includes('#') ? link.substring(link.lastIndexOf('#') + 1) : '';
            let linkName = '';
            try { linkName = decodeURIComponent(rawHash || ''); } catch {}
            if (!linkName || /:\/\//.test(linkName)) linkName = `Link-${i + 1}`;
            console.log(`Testing sing-box config ${i + 1}/${testLinks.length}: ${linkName}`);
          
            try {
              // Parse link
              const bean = sandbox.parseLink(link);
          
              // Generate sing-box config
              const outbound = sandbox.buildSingBoxOutbound(bean);
              // Multi-link path builds per-inbound selectors; for single link emulate multi by duplicating
              let config;
              if (i === 0) {
                // Single-link config (kept for coverage), also exercise named TUN
                const ob = Object.assign({tag: 'p1'}, outbound);
                config = sandbox.buildSingBoxConfig([ob], {addTun: true, addSocks: true, tunName: 'tun0'});
              } else {
                // Multi-config: use the same outbound twice to simulate multiple choices and multiple TUNs
                const ob1 = Object.assign({tag: 'p1'}, outbound);
                const ob2 = Object.assign({tag: 'p2'}, outbound);
                config = sandbox.buildSingBoxConfig([ob1, ob2], {addTun: true, addSocks: true, tunName: 'tun0,tun_ru,tun_auto'});
              }
          
              // Assert: TUN inbound exists
              const tunInbound = (config.inbounds || []).find(i => i.type === 'tun');
              if (!tunInbound) {
                throw new Error('missing tun inbound');
              }

              // Write config to file
              const configFile = `test_singbox_${i}.json`;
              fs.writeFileSync(configFile, JSON.stringify(config, null, 2));
          
              // Validate with sing-box (syntax)
              const { execSync } = require('child_process');
              try {
                const result = execSync(`sing-box check -c ${configFile}`, { 
                  stdio: 'pipe',
                  encoding: 'utf8'
                });
                console.log(`‚úÖ Config ${i + 1} is valid`);
                validTests++;
              } catch (error) {
                console.log(`‚ùå Config ${i + 1} failed validation:`);
                console.log(`   Error: ${error.message}`);
                if (error.stdout) console.log(`   Stdout: ${error.stdout}`);
                if (error.stderr) console.log(`   Stderr: ${error.stderr}`);
                failedTests++;
              }

              // Optional run smoke test for SOCKS-only inbound (avoid TUN in CI) ‚Äî FAILS build on error
              try {
                const cfgObj = JSON.parse(fs.readFileSync(configFile, 'utf8'));
                cfgObj.inbounds = [{ tag: 'mixed-in', type: 'mixed', listen: '127.0.0.1', listen_port: 2080 }];
                // route final:
                // - prefer existing selector if present
                // - otherwise keep existing final if set
                // - otherwise fall back to 'direct' (safe default)
                const firstSelector = (cfgObj.outbounds || []).find(o => o.type === 'selector')?.tag;
                cfgObj.route = cfgObj.route || {};
                cfgObj.route.final = firstSelector || cfgObj.route.final || 'direct';
                const runFile = `run_singbox_${i}.json`;
                fs.writeFileSync(runFile, JSON.stringify(cfgObj, null, 2));
                const cmd = `bash -lc 'tmp=$(mktemp); sing-box run -c ${runFile} >$tmp 2>&1 & pid=$!; sleep 2; kill $pid || true; cat $tmp; rm -f $tmp'`;
                const out = execSync(cmd, { stdio: 'pipe', encoding: 'utf8' });
                if (!/(sing-box started|tcp server started at 127\\.0\\.0\\.1:2080)/.test(out)) {
                  throw new Error(`sing-box did not report start\n--- LOG START ---\n${out}\n--- LOG END ---`);
                }
                console.log(`üöÄ Run smoke test passed for ${i + 1}`);
                fs.unlinkSync(runFile);
              } catch (error) {
                console.log(`‚ùå Run smoke test failed: ${error.message}`);
                // Extra: run a syntax re-check of the run file to surface precise error, if any
                try {
                  const runFile = `run_singbox_${i}.json`;
                  const chk = execSync(`sing-box check -c ${runFile}`, { stdio: 'pipe', encoding: 'utf8' });
                  console.log(`   sing-box check output:\n${chk}`);
                } catch (e2) {
                  if (e2.stdout) console.log(`   Check stdout:\n${e2.stdout}`);
                  if (e2.stderr) console.log(`   Check stderr:\n${e2.stderr}`);
                }
                failedTests++;
              }
          
              // Clean up
              fs.unlinkSync(configFile);
          
            } catch (error) {
              console.log(`‚ùå Config ${i + 1} generation failed:`, error.message);
              failedTests++;
            }
          }
          
          // Multi-config test: combine ALL links into one config and validate
          try {
            const selected = testLinks.map(l => sandbox.parseLink(l));
            const used = new Set();
            const multiOutbounds = selected.map((b, idx) => {
              const ob = sandbox.buildSingBoxOutbound(b);
              const tag = sandbox.computeTag ? sandbox.computeTag(b, used) : `p${idx + 1}`;
              return Object.assign({ tag }, ob);
            });
            // Mixed modes test: tun0:select,tun1:auto
            const multiConfig = sandbox.buildSingBoxConfig(multiOutbounds, { addTun: true, addSocks: true, tunName: 'tun0:select,tun1:auto' });
            const multiFile = `test_singbox_multi_all.json`;
            fs.writeFileSync(multiFile, JSON.stringify(multiConfig, null, 2));

            const { execSync } = require('child_process');
            // Syntax check
            execSync(`sing-box check -c ${multiFile}`, { stdio: 'pipe', encoding: 'utf8' });
            // Smoke run (SOCKS-only)
            const cfgObj = JSON.parse(fs.readFileSync(multiFile, 'utf8'));
            cfgObj.inbounds = [{ tag: 'mixed-in', type: 'mixed', listen: '127.0.0.1', listen_port: 2080 }];
            if (cfgObj.outbounds && cfgObj.outbounds.length) {
              const firstSelector = cfgObj.outbounds.find(o => o.type === 'selector')?.tag;
              cfgObj.route = cfgObj.route || {};
              cfgObj.route.final = firstSelector || cfgObj.route.final || 'direct';
            }
            const runFile = `run_singbox_multi_all.json`;
            fs.writeFileSync(runFile, JSON.stringify(cfgObj, null, 2));
            const cmd = `bash -lc 'tmp=$(mktemp); sing-box run -c ${runFile} >$tmp 2>&1 & pid=$!; sleep 2; kill $pid || true; cat $tmp; rm -f $tmp'`;
            const out = execSync(cmd, { stdio: 'pipe', encoding: 'utf8' });
            if (!/(sing-box started|tcp server started at 127\\.0\\.0\\.1:2080)/.test(out)) {
              throw new Error(`sing-box did not report start (multi-all)\n--- LOG START ---\n${out}\n--- LOG END ---`);
            }
            console.log('‚úÖ Multi-config (ALL links) valid and started');
            fs.unlinkSync(multiFile);
            fs.unlinkSync(runFile);
          } catch (error) {
            console.log(`‚ùå Multi-config test failed: ${error.message}`);
            process.exit(1);
          }

          console.log(`\nüìä Results: ${validTests} valid, ${failedTests} failed`);
          
          if (failedTests > 0) {
            console.log(`\n‚ùå ${failedTests} configs failed validation`);
            process.exit(1);
          } else {
            console.log(`\n‚úÖ All ${testLinks.length} sing-box configs are valid`);
          }
          EOF
          
          # Run the test
          node test_singbox.js

  validate-singbox-extended:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          cache: false
          go-version: '1.21'

      - name: Download sing-box extended
        run: |
          # Get latest release info
          LATEST_RELEASE=$(curl -s https://api.github.com/repos/shtorm-7/sing-box-extended/releases/latest)
          DOWNLOAD_URL=$(echo $LATEST_RELEASE | jq -r '.assets[] | select(.name | contains("linux-amd64.tar.gz")) | .browser_download_url')
          VERSION=$(echo $LATEST_RELEASE | jq -r '.tag_name')
          
          echo "Downloading sing-box extended $VERSION from $DOWNLOAD_URL"
          wget -O sing-box-extended.tar.gz "$DOWNLOAD_URL"
          tar -xzf sing-box-extended.tar.gz
          sudo mv sing-box-*/sing-box /usr/local/bin/sing-box-extended
          chmod +x /usr/local/bin/sing-box-extended


      - name: Run Extended Configs with sing-box extended
        env:
          CONFIGS: ${{ secrets.CONFIGS }}
          MIERU_JSON: ${{ secrets.MIERU_JSON }}
          SDNS_LINK: ${{ secrets.SDNS_LINK }}
          XHTTP_LINK: ${{ secrets.XHTTP_LINK }}
        run: |
          echo "Running extended configs with sing-box extended..."
          
          # Test all existing configs with extended features
          echo "Testing existing configs with extended features..."
          node -e "
          const fs = require('fs');
          const vm = require('vm');
          const { execSync } = require('child_process');
          
          const mainJs = fs.readFileSync('src/main.js', 'utf8');
          const singboxJs = fs.readFileSync('src/core/singbox.js', 'utf8');
          const sandbox = {
            console: console,
            require: require,
            module: { exports: {} },
            exports: {},
            global: global,
            process: process,
            Buffer: Buffer,
            setTimeout: setTimeout,
            setInterval: setInterval,
            clearTimeout: clearTimeout,
            clearInterval: clearInterval,
            URL: require('url').URL,
            atob: (str) => Buffer.from(str, 'base64').toString('binary'),
            btoa: (str) => Buffer.from(str, 'binary').toString('base64')
          };
          
          vm.createContext(sandbox);
          vm.runInContext(mainJs, sandbox);
          vm.runInContext(singboxJs, sandbox);
          
          const testLinksContent = process.env.CONFIGS;
          const testLinks = testLinksContent
            .split('\n')
            .map(line => line.trim())
            .filter(line => line && !line.startsWith('//') && !line.startsWith('#'))
            .filter(line => line.includes('://'));
          
          console.log('Testing', testLinks.length, 'existing links with extended features...');
          
          let failedTests = 0;
          let validTests = 0;
          
          for (let i = 0; i < testLinks.length; i++) {
            const link = testLinks[i];
            const rawHash = link.includes('#') ? link.substring(link.lastIndexOf('#') + 1) : '';
            let linkName = '';
            try { linkName = decodeURIComponent(rawHash || ''); } catch {}
            if (!linkName || /:\/\//.test(linkName)) linkName = \`Link-\${i + 1}\`;
            console.log(\`Testing extended config \${i + 1}/\${testLinks.length}: \${linkName}\`);
          
            try {
              const bean = sandbox.parseLink(link);
              const outbound = sandbox.buildSingBoxOutbound(bean);
              const config = sandbox.buildSingBoxConfig([{tag: 'test', ...outbound}], {useExtended: true});
          
              const configFile = \`test_extended_\${i}.json\`;
              fs.writeFileSync(configFile, JSON.stringify(config, null, 2));
          
              const cmd = \`bash -lc 'tmp=\$(mktemp); /usr/local/bin/sing-box-extended run -c \${configFile} >\$tmp 2>&1 & pid=\$!; sleep 2; kill \$pid || true; cat \$tmp; rm -f \$tmp'\`;
              const out = execSync(cmd, { stdio: 'pipe', encoding: 'utf8' });
              if (!/(sing-box started|inbound\\/.*server started)/.test(out)) {
                throw new Error('sing-box-extended did not report start');
              }
              console.log(\`‚úÖ Extended config \${i + 1} is valid\`);
              validTests++;
              fs.unlinkSync(configFile);
            } catch (error) {
              console.log(\`‚ùå Extended config \${i + 1} failed: \${error.message}\`);
              failedTests++;
            }
          }
          
          console.log(\`\nüìä Extended Results: \${validTests} valid, \${failedTests} failed\`);
          
          if (failedTests > 0) {
            console.log(\`\n‚ùå \${failedTests} extended configs failed validation\`);
            process.exit(1);
          } else {
            console.log(\`\n‚úÖ All \${testLinks.length} extended configs are valid\`);
          }
          "
          
          # Test Mieru config
          echo "Testing Mieru config..."
          node -e "
          const fs = require('fs');
          const vm = require('vm');
          
          const mainJs = fs.readFileSync('src/main.js', 'utf8');
          const singboxJs = fs.readFileSync('src/core/singbox.js', 'utf8');
          const sandbox = {
            console: console,
            require: require,
            module: { exports: {} },
            exports: {},
            global: global,
            process: process,
            Buffer: Buffer,
            setTimeout: setTimeout,
            setInterval: setInterval,
            clearTimeout: clearTimeout,
            clearInterval: clearInterval,
            URL: require('url').URL,
            atob: (str) => Buffer.from(str, 'base64').toString('binary'),
            btoa: (str) => Buffer.from(str, 'binary').toString('base64')
          };
          
          vm.createContext(sandbox);
          vm.runInContext(mainJs, sandbox);
          vm.runInContext(singboxJs, sandbox);
          
          const beans = sandbox.buildBeansFromInput(process.env.MIERU_JSON);
          const outbounds = beans.map(b => {
            const outbound = sandbox.buildSingBoxOutbound(b);
            return {tag: 'test', ...outbound};
          });
          const config = sandbox.buildSingBoxConfig(outbounds, {useExtended: true});
          fs.writeFileSync('/tmp/mieru-config.json', JSON.stringify(config, null, 2));
          "
          
          cmd="bash -lc 'tmp=\$(mktemp); /usr/local/bin/sing-box-extended run -c /tmp/mieru-config.json >\$tmp 2>&1 & pid=\$!; sleep 2; kill \$pid || true; cat \$tmp; rm -f \$tmp'"
          out=$(eval $cmd)
          if ! echo "$out" | grep -Eq "sing-box started|server started"; then
            echo "‚ùå Mieru config failed to start"
            echo "$out"
            exit 1
          fi
          echo "‚úÖ Mieru config ran successfully"
          
          # Test SDNS config
          echo "Testing SDNS config..."
          node -e "
          const fs = require('fs');
          const vm = require('vm');
          
          const mainJs = fs.readFileSync('src/main.js', 'utf8');
          const singboxJs = fs.readFileSync('src/core/singbox.js', 'utf8');
          const sandbox = {
            console: console,
            require: require,
            module: { exports: {} },
            exports: {},
            global: global,
            process: process,
            Buffer: Buffer,
            setTimeout: setTimeout,
            setInterval: setInterval,
            clearTimeout: clearTimeout,
            clearInterval: clearInterval,
            URL: require('url').URL,
            atob: (str) => Buffer.from(str, 'base64').toString('binary'),
            btoa: (str) => Buffer.from(str, 'binary').toString('base64')
          };
          
          vm.createContext(sandbox);
          vm.runInContext(mainJs, sandbox);
          vm.runInContext(singboxJs, sandbox);
          
          const beans = sandbox.buildBeansFromInput(process.env.SDNS_LINK);
          const config = sandbox.buildSingBoxConfig([], {useExtended: true, dnsBeans: beans});
          fs.writeFileSync('/tmp/sdns-config.json', JSON.stringify(config, null, 2));
          "
          
          cmd="bash -lc 'tmp=\$(mktemp); /usr/local/bin/sing-box-extended run -c /tmp/sdns-config.json >\$tmp 2>&1 & pid=\$!; sleep 2; kill \$pid || true; cat \$tmp; rm -f \$tmp'"
          out=$(eval $cmd)
          if ! echo "$out" | grep -Eq "sing-box started|server started"; then
            echo "‚ùå SDNS config failed to start"
            echo "$out"
            exit 1
          fi
          echo "‚úÖ SDNS config ran successfully"
          
          # Test XHTTP config
          echo "Testing XHTTP config..."
          node -e "
          const fs = require('fs');
          const vm = require('vm');
          
          const mainJs = fs.readFileSync('src/main.js', 'utf8');
          const singboxJs = fs.readFileSync('src/core/singbox.js', 'utf8');
          const sandbox = {
            console: console,
            require: require,
            module: { exports: {} },
            exports: {},
            global: global,
            process: process,
            Buffer: Buffer,
            setTimeout: setTimeout,
            setInterval: setInterval,
            clearTimeout: clearTimeout,
            clearInterval: clearInterval,
            URL: require('url').URL,
            atob: (str) => Buffer.from(str, 'base64').toString('binary'),
            btoa: (str) => Buffer.from(str, 'binary').toString('base64')
          };
          
          vm.createContext(sandbox);
          vm.runInContext(mainJs, sandbox);
          vm.runInContext(singboxJs, sandbox);
          
          const beans = sandbox.buildBeansFromInput(process.env.XHTTP_LINK);
          const outbounds = beans.map(b => {
            const outbound = sandbox.buildSingBoxOutbound(b);
            return {tag: 'test', ...outbound};
          });
          const config = sandbox.buildSingBoxConfig(outbounds, {useExtended: true});
          fs.writeFileSync('/tmp/xhttp-config.json', JSON.stringify(config, null, 2));
          "
          
          cmd="bash -lc 'tmp=\$(mktemp); /usr/local/bin/sing-box-extended run -c /tmp/xhttp-config.json >\$tmp 2>&1 & pid=\$!; sleep 2; kill \$pid || true; cat \$tmp; rm -f \$tmp'"
          out=$(eval $cmd)
          if ! echo "$out" | grep -Eq "sing-box started|server started"; then
            echo "‚ùå XHTTP config failed to start"
            echo "$out"
            exit 1
          fi
          echo "‚úÖ XHTTP config ran successfully"
          
          echo "üéâ All extended configs ran successfully!"

  validate-xray:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          cache: false
          go-version: '1.21'

      - name: Download Xray
        run: |
          # Get latest release info
          LATEST_RELEASE=$(curl -s https://api.github.com/repos/XTLS/Xray-core/releases/latest)
          DOWNLOAD_URL=$(echo $LATEST_RELEASE | jq -r '.assets[] | select(.name == "Xray-linux-64.zip") | .browser_download_url')
          VERSION=$(echo $LATEST_RELEASE | jq -r '.tag_name')
          
          echo "Downloading Xray $VERSION from $DOWNLOAD_URL"
          wget -O xray.zip "$DOWNLOAD_URL"
          rm -rf /tmp/xray && mkdir -p /tmp/xray
          unzip -q xray.zip -d /tmp/xray
          sudo mv /tmp/xray/xray /usr/local/bin/
          chmod +x /usr/local/bin/xray

      - name: Generate and validate Xray configs
        env:
          CONFIGS: ${{ secrets.CONFIGS }}
        run: |
          # Create test script
          cat > test_xray.js << 'EOF'
          // Load main.js functions
          const fs = require('fs');
          const vm = require('vm');
          
          // Read main.js content
          const mainJs = fs.readFileSync('src/main.js', 'utf8');
          const xrayJs = fs.readFileSync('src/core/xray.js', 'utf8');
          
          // Create sandbox with required globals
          const sandbox = {
            console: console,
            require: require,
            module: { exports: {} },
            exports: {},
            global: global,
            process: process,
            Buffer: Buffer,
            setTimeout: setTimeout,
            setInterval: setInterval,
            clearTimeout: clearTimeout,
            clearInterval: clearInterval,
            // Browser APIs for Node.js
            URL: require('url').URL,
            atob: (str) => Buffer.from(str, 'base64').toString('binary'),
            btoa: (str) => Buffer.from(str, 'binary').toString('base64')
          };
          
          // Execute main.js in sandbox
          vm.createContext(sandbox);
          vm.runInContext(mainJs, sandbox);
          vm.runInContext(xrayJs, sandbox);
          
          // Read test links
          const testLinksContent = process.env.CONFIGS;
          const allTestLinks = testLinksContent
            .split('\n')
            .map(line => line.trim())
            .filter(line => line && !line.startsWith('//') && !line.startsWith('#'))
            .filter(line => line.includes('://'));
          
          // Filter out protocols not supported by Xray (hy2, tuic)
          const testLinks = allTestLinks.filter(link => 
            !link.startsWith('hy2://') && !link.startsWith('tuic://')
          );
          
          console.log(`Found ${testLinks.length} test links (excluding hy2/tuic for Xray)`);
          
          let failedTests = 0;
          let validTests = 0;
          
          for (let i = 0; i < testLinks.length; i++) {
            const link = testLinks[i];
            const rawHash2 = link.includes('#') ? link.substring(link.lastIndexOf('#') + 1) : '';
            let linkName = '';
            try { linkName = decodeURIComponent(rawHash2 || ''); } catch {}
            if (!linkName || /:\/\//.test(linkName)) linkName = `Link-${i + 1}`;
            console.log(`Testing Xray config ${i + 1}/${testLinks.length}: ${linkName}`);
          
            try {
              // Parse link
              const bean = sandbox.parseLink(link);
          
              // Generate Xray config
              const outbound = sandbox.buildXrayOutbound(bean);
              const config = sandbox.buildXrayConfig(outbound);
          
              // Write config to file
              const configFile = `test_xray_${i}.json`;
              fs.writeFileSync(configFile, JSON.stringify(config, null, 2));
          
              // Validate with Xray
              const { execSync } = require('child_process');
              try {
                const result = execSync(`xray -test -config ${configFile}`, { 
                  stdio: 'pipe',
                  encoding: 'utf8'
                });
                console.log(`‚úÖ Config ${i + 1} is valid`);
                validTests++;
              } catch (error) {
                console.log(`‚ùå Config ${i + 1} failed validation:`);
                console.log(`   Error: ${error.message}`);
                if (error.stdout) console.log(`   Stdout: ${error.stdout}`);
                if (error.stderr) console.log(`   Stderr: ${error.stderr}`);
                failedTests++;
              }
          
              // Multi-config test: combine ALL supported links into one Xray config and validate
              try {
              const selected = testLinks
                .filter(l => !l.startsWith('hy2://') && !l.startsWith('tuic://'))
                .map(l => sandbox.parseLink(l));
                const used = new Set();
                const multiOutbounds = selected.map((b, idx) => {
                  const ob = sandbox.buildXrayOutbound(b);
                  // ensure unique tags for multi config
                  ob.tag = sandbox.computeTag ? sandbox.computeTag(b, used) : `p${idx + 1}`;
                  return ob;
                });
                const multiConfig = sandbox.buildXrayConfig(multiOutbounds);
                const multiFile = `test_xray_multi_all.json`;
                fs.writeFileSync(multiFile, JSON.stringify(multiConfig, null, 2));
          
                const { execSync } = require('child_process');
                execSync(`xray -test -config ${multiFile}`, { stdio: 'pipe', encoding: 'utf8' });
                console.log('‚úÖ Xray multi-config (ALL links) valid');
                fs.unlinkSync(multiFile);

                // Balancer-enabled multi-config
                try {
                  const multiConfigBal = sandbox.buildXrayConfig(multiOutbounds, { enableBalancer: true });
                  const multiFileBal = `test_xray_multi_all_balancer.json`;
                  fs.writeFileSync(multiFileBal, JSON.stringify(multiConfigBal, null, 2));
                  execSync(`xray -test -config ${multiFileBal}`, { stdio: 'pipe', encoding: 'utf8' });
                  console.log('‚úÖ Xray multi-config (ALL links, balancer) valid');
                  fs.unlinkSync(multiFileBal);
                } catch (e) {
                  console.log(`‚ùå Xray multi-config (balancer) test failed: ${e.message}`);
                  if (e.stdout) console.log(`   Stdout: ${e.stdout}`);
                  if (e.stderr) console.log(`   Stderr: ${e.stderr}`);
                  process.exit(1);
                }
              } catch (error) {
                console.log(`‚ùå Xray multi-config test failed: ${error.message}`);
                process.exit(1);
              }
          
              // Clean up
              fs.unlinkSync(configFile);
          
            } catch (error) {
              console.log(`‚ùå Config ${i + 1} generation failed:`, error.message);
              failedTests++;
            }
          }
          
          console.log(`\nüìä Results: ${validTests} valid, ${failedTests} failed`);
          
          if (failedTests > 0) {
            console.log(`\n‚ùå ${failedTests} configs failed validation`);
            process.exit(1);
          } else {
            console.log(`\n‚úÖ All ${testLinks.length} Xray configs are valid`);
          }
          EOF
          
          # Run the test
          node test_xray.js

  validate-mihomo:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Download Mihomo
        run: |
          set -e
          API_JSON=$(curl -s https://api.github.com/repos/MetaCubeX/mihomo/releases/latest)
          VERSION=$(echo "$API_JSON" | jq -r '.tag_name')
          echo "Latest Mihomo version: $VERSION"

          # Prefer linux-amd64 .gz assets (v3 > v2 > v1)
          URL=$(echo "$API_JSON" | jq -r '
            (
              .assets[] | select(.name | test("^mihomo-linux-amd64-v3-.*\\.gz$")) | .browser_download_url
            ),(
              .assets[] | select(.name | test("^mihomo-linux-amd64-v2-.*\\.gz$")) | .browser_download_url
            ),(
              .assets[] | select(.name | test("^mihomo-linux-amd64-v1-.*\\.gz$")) | .browser_download_url
            ) | select(.!=null) | .  ' | head -n1)
          if [[ -z "$URL" ]]; then echo "Failed to resolve Mihomo download URL"; exit 1; fi
          echo "Downloading Mihomo from $URL"
          wget -O /tmp/mihomo.dl "$URL"
          # All selected artifacts are .gz: write decompressed binary
          gunzip -c /tmp/mihomo.dl | sudo tee /usr/local/bin/mihomo >/dev/null
          sudo chmod +x /usr/local/bin/mihomo

      - name: Generate and validate Mihomo configs
        env:
          CONFIGS: ${{ secrets.CONFIGS }}
          WG_CONF: ${{ secrets.WG_CONF }}
        run: |
          # Create test script
          cat > test_mihomo.js << 'EOF'
          const fs = require('fs');
          const vm = require('vm');
          const { execSync } = require('child_process');
          const mainJs = fs.readFileSync('src/main.js', 'utf8');
          const mihomoJs = fs.readFileSync('src/core/mihomo.js', 'utf8');
          const yamlJs = fs.readFileSync('src/core/yaml.js', 'utf8');
          const wireguardJs = fs.readFileSync('src/core/wireguard.js', 'utf8');
          const sandbox = {
            console, require, module: {exports:{}}, exports: {}, global, process, Buffer,
            URL: require('url').URL,
            atob: (s)=>Buffer.from(s,'base64').toString('binary'),
            btoa: (s)=>Buffer.from(s,'binary').toString('base64')
          };
          vm.createContext(sandbox);
          vm.runInContext(mainJs, sandbox);
          vm.runInContext(mihomoJs, sandbox);
          vm.runInContext(yamlJs, sandbox);
          vm.runInContext(wireguardJs, sandbox);

          const raw = process.env.CONFIGS || '';
          const links = raw.split('\n').map(s=>s.trim()).filter(s=>s && !s.startsWith('#') && s.includes('://'));
          const beans = links
            .map(l => sandbox.parseLink(l))
            .filter(b => !['mieru','sdns'].includes(b.proto))
            .filter(b => !(b.proto === 'socks' && b.socks && b.socks.type === 'socks4'));

          let fail = 0, ok = 0;
          console.log('Found', beans.length, 'Mihomo-compatible links');

          for (let i=0;i<beans.length;i++){
            try{
              const bean = beans[i];
              const cfgObj = sandbox.buildMihomoConfig([bean]);
              const yaml = sandbox.buildMihomoYaml(cfgObj.proxies, cfgObj['proxy-groups'], null, null, cfgObj.listeners);
              const f = `mihomo_${i}.yaml`;
              fs.writeFileSync(f, yaml);
              console.log(`Testing Mihomo config ${i+1}/${beans.length}: ${cfgObj.proxies[0].name || 'unnamed'}`);
              const out = execSync(`mihomo -t -f ${f}`, {stdio:'pipe', encoding:'utf8'});
              // mihomo -t prints nothing on success; keep a marker for traceability
              console.log(`‚úÖ Passed ${i+1}`);
              ok++;
            }catch(e){
              console.log('‚ùå Mihomo single config failed:', e.message);
              if (e.stdout) console.log('   Stdout:', e.stdout.toString());
              if (e.stderr) console.log('   Stderr:', e.stderr.toString());
              fail++;
            }
          }

          // Multi-config
          try{
            const cfgObj = sandbox.buildMihomoConfig(beans);
            const yaml = sandbox.buildMihomoYaml(cfgObj.proxies, cfgObj['proxy-groups'], null, null, cfgObj.listeners);
            fs.writeFileSync('mihomo_all.yaml', yaml);
            execSync('mihomo -t -f mihomo_all.yaml', {stdio:'pipe', encoding:'utf8'});
            console.log('‚úÖ Mihomo multi-config valid');
          }catch(e){
            console.log('‚ùå Mihomo multi-config failed:', e.message);
            process.exit(1);
          }

          if (fail>0){
            console.log(`‚ùå ${fail} Mihomo configs failed, ${ok} passed`);
            process.exit(1);
          } else {
            console.log(`‚úÖ All ${ok} Mihomo configs passed`);
          }

          // Optional WireGuard/AmneziaWG config check (plain .conf provided via WG_CONF secret)
          const wgConf = process.env.WG_CONF || '';
          if (wgConf.trim()) {
            try {
              const bean = sandbox.parseWireGuardConf(wgConf, 'wg-ci.conf');
              sandbox.validateBean(bean);
              const cfgObj = sandbox.buildMihomoConfig([bean]);
              const yaml = sandbox.buildMihomoYaml(cfgObj.proxies, cfgObj['proxy-groups'], null, null, cfgObj.listeners);
              fs.writeFileSync('mihomo_wg.yaml', yaml);
              execSync('mihomo -t -f mihomo_wg.yaml', {stdio:'pipe', encoding:'utf8'});
              console.log('‚úÖ Mihomo WireGuard config valid');
            } catch (e) {
              console.log('‚ùå Mihomo WireGuard config failed:', e.message);
              if (e.stdout) console.log('   Stdout:', e.stdout.toString());
              if (e.stderr) console.log('   Stderr:', e.stderr.toString());
              process.exit(1);
            }
          } else {
            console.log('‚ÑπÔ∏è No WG_CONF provided; skipping WireGuard test');
          }
          EOF

          node test_mihomo.js

  build:
    runs-on: ubuntu-latest
    needs: [ validate-singbox, validate-singbox-extended, validate-xray, validate-mihomo ]
    if: github.ref == 'refs/heads/main'

    concurrency:
      group: "pages"
      cancel-in-progress: false

    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Pages
        uses: actions/configure-pages@v5
      - name: Build static site
        run: |
          mkdir -p _site
          cp -r src/* _site/
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3

  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
